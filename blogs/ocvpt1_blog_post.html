<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,700" rel="stylesheet">

    <link rel="stylesheet" href="css/open-iconic-bootstrap.min.css">
    <link rel="stylesheet" href="css/animate.css">
    
    <link rel="stylesheet" href="css/owl.carousel.min.css">
    <link rel="stylesheet" href="css/owl.theme.default.min.css">
    <link rel="stylesheet" href="css/magnific-popup.css">

    <link rel="stylesheet" href="css/aos.css">

    <link rel="stylesheet" href="css/ionicons.min.css">

    <link rel="stylesheet" href="css/bootstrap-datepicker.css">
    <link rel="stylesheet" href="css/jquery.timepicker.css">

    
    <link rel="stylesheet" href="css/flaticon.css">
    <link rel="stylesheet" href="css/icomoon.css">
    <link rel="stylesheet" href="css/style.css">
  </head>
  <body>

    <div class="KW_progressContainer">
      <div class="KW_progressBar">

      </div>
    </div>
    <div class="page">
    <nav id="colorlib-main-nav" role="navigation">
      <a href="#" class="js-colorlib-nav-toggle colorlib-nav-toggle active"><i></i></a>
      <div class="js-fullheight colorlib-table">
      	<div class="img" style="background-image: url(../images/ishan2.jpg);"></div>
        <div class="colorlib-table-cell js-fullheight">
          <div class="row no-gutters">
            <div class="col-md-12 text-center">
              <h1 class="mb-4"><a href="../index.html" class="logo">Ishan Dixit</a></h1>
              <ul>
                <li><a href="../index.html"><span><small>01</small>Home</span></a></li>
                <li><a href="../about.html"><span><small>02</small>Resume</span></a></li>
                <li><a href="../portfolio.html"><span><small>03</small>Portfolio</span></a></li>
                <li class="active"><a href="blog.html"><span><small>04</small>Blog</span></a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </nav>
    
    <div id="colorlib-page">
      <header>
        <div class="container">
          <div class="row">
            <div class="col-md-12">
              <div class="colorlib-navbar-brand">
                <a class="colorlib-logo" href="../index.html"><span class="logo-img" style="background-image: url(../images/person_1.jpg);"></span>Ishan Dixit</a>
              </div>
              <a href="#" class="js-colorlib-nav-toggle colorlib-nav-toggle"><i></i></a>
            </div>
          </div>
        </div>
      </header>

      <section class="ftco-section">
        <div class="container mt-5">
        	<div class="row justify-content-center mb-5 pb-5">
            <div class="col-md-7 text-center heading-section ftco-animate">
              <span>Blog</span>
              <h2>Musings of a Developer</h2>
            </div>
          </div>
          <div class="row d-flex justify-content-center">
            <div class="col-md-8">
              <h2 class="mb-3">Image processing using Python & Open-CV part-1</h2>
              <p>
                <!-- <img src="1_BIpRgx5FsEMhr1k2EqBKFg.gif"> -->
              </p>
              <p>
                Hello, and welcome to the “Image processing with Python & Open-CV tutorial series”. This series aims at providing an overview of the Open-CV library, Its functions, application & capabilities along with getting your hands adept with it.
              </p>
              <p>
                At first glance, the word “Image processing” might seem something of a wizard’s stuff. As the name suggests, Image processing basically means performing processes on an image with the help of software. The goal of applying processes like smoothing, sharpening, contrasting, stretching etc on an image can be to increase its readability or to enhance its quality or even transform the image. That being said, image processing is a part of computer vision. Computer vision is an extraordinarily powerful field in the world of artificial intelligence and it has got enormous amounts of applications in real time. These include detecting license plates, scanning whiteboard contents, detecting text in still images, re-scaling images, detecting templates in images, image recognition, image retrieval, image restoration etc and so many more.
              </p>
              <p>
                Open-CV is an open source computer vision library developed by Intel for real-time image & video analysis and processing. Primarily written in C++, This library has bindings for Python, Java, Matlab, Octave etc. Open-CV combined with python makes image/video analysis and processing astonishingly simple and for many, it can also be the first step in the world of Computer Vision.
              </p>
              <p>
                This part of the tutorial will show us the basics of using open-CV with Python and also that just how simple it is to get started with Image processing. Let’s get started and get our hands dirty.
              </p>
              <p>
                First program will be to convert a video to its Gray scaled form. The video is captured from the webcam.
              </p>
              <p>
                <code>
                  #BASIC GREY-SCALING<br>
                  import cv2<br><br>
                  cap = cv2.VideoCapture(0)<br><br>
                  while True:<br>
                  &ensp;&ensp;&ensp;&ensp;frame, ret = cap.read()<br>
                  &ensp;&ensp;&ensp;&ensp;gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('frame', frame)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('gray_frame', gray)<br><br>
                  &ensp;&ensp;&ensp;&ensp;if cv2.waitKey(20) and 0xFF == ord('q'):<br>
                  &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;break<br><br>
                  cap.release()<br>
                  cv2.destroyAllWindows()
                </code>
              </p>
              <p>
                Breaking down the code step by step :
              </p>
              <p>
                <ol>
                  <li>
                    we import the necessary libraries.
                  </li>
                  <li>
                    Then ‘cv2.VideoCapture(0)’ starts capturing from the default camera(here 0 means default camera).
                  </li>
                  <li>
                    Capturing frames in an infinite loop will be next step. After that, we convert the captured video into a gray-scale via ‘cv2.COLOR_BGR2GRAY’ command(Open -CV captures in Blue-Green-Red as opposed to Red-Green-Blue).
                  </li>
                  <li>
                    We output both the frames(original video and gray-scaled video) by ‘cv2.imshow’ command
                  </li>
                  <li>
                    To quit from the setup, we need to define a key. In our case “q” is the key we have defined to break the loop.
                  </li>
                  <li>
                    Lastly we release all the cameras from the open-CV and destroy all the windows opened in the background. This is done in order to release all the background process happening after quitting the setup.
                  </li>
                </ol>
              </p>
              <p>
                <b>This stage is crucial to understand as all the programs here onward will be based on this particular setup</b>. Most of the programs will be built upon this code. Also, the logic behind all the video analysis applications will be pretty similar. First we need to capture the video/images, then to apply various process to them and lastly to manipulate the image/video into a desirable output.
              </p>
              <p>
                The second program will be to re-scale the video to a certain percentage of the the original frame. Re-scaling is not done on the video/capture, but on the frame output itself.
              </p>
              <p>
                <code>
                  #RE-SCALING<br>
                  import cv2<br><br>
                  cap = cv2.VideoCapture(0)<br><br>
                  def rescale_frame(frame, percentage = 75):<br>
                  &ensp;&ensp;&ensp;&ensp;width = int(frame.shape[1] * percent / 100)<br>
                  &ensp;&ensp;&ensp;&ensp;height = int(frame.shape[0] * percent / 100)<br>
                  &ensp;&ensp;&ensp;&ensp;dim = (width, height)<br>
                  &ensp;&ensp;&ensp;&ensp;return cv2.resize(frame, dim, interpolation = cv2.INTER_AREA)<br><br>
                  while True:<br>
                  &ensp;&ensp;&ensp;&ensp;frame, ret = cap.read()<br>
                  &ensp;&ensp;&ensp;&ensp;frame75 = rescale_frame(frame, percentage = 75)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('frame75', frame75)<br>
                  &ensp;&ensp;&ensp;&ensp;frame150 = rescale_frame(frame, percentage = 150)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('frame150', frame150)<br>
                  &ensp;&ensp;&ensp;&ensp;if cv2.waitKey(0) and 0xFF == ord('q'):<br>
                  &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;break<br><br>
                  cap.release()<br>
                  cv2.destroyAllWindows()
                </code>
              </p>
              <p>
                As we can see all of the code is pretty similar to the very first program of Grey-scaling with the only difference being the function re-scale. All this function does is it takes the dimensions of the frame and scales those dimensions to the percentage value we desire.
              </p>
              <p>
                After the topic of re-scaling, we will be moving towards actually changing the resolution of the video and not just scaling the frame to a certain percentage value.
              </p>
              <p>
                <code>
                  #CHANGING RESOLUTION<br>
                  import cv2<br><br>
                  cap = cv2.VideoCapture(0)<br><br>
                  def make_1080():<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(3, 1920)<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(4, 1080)<br><br>
                  def make_720():<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(3, 1280)<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(4, 720)<br><br>
                  def make_480():<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(3, 640)<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(3, 480)<br><br>
                  def change_resolution(width, height):<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(3, width)<br>
                  &ensp;&ensp;&ensp;&ensp;cap.set(4, height)<br><br>
                  make_720()<br><br>
                  while True:<br>
                  &ensp;&ensp;&ensp;&ensp;ret, frame = cap.read()<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('frame', frame)<br>
                   
                  &ensp;&ensp;&ensp;&ensp;if cv2.waitKey(20) and 0xFF == ord('q'):<br>
                  &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;break<br><br>
                  cap.release()<br>
                  cv2.destroyAllWindows()<br>
                </code>
              </p>
              <p>
                This code is fairly simple and straight forward as well. We make a function that sets the width and height of the video capture ’cap’ to the desired resolution values. For a resolution of 480p, the height will be equal to 480 and the width will be equal to 640. Similarly for the resolutions of 720p and 1080p the heights and widths will be equal to 720 & 1280 and 1080 & 1920 respectively. One thing here to note is that as the resolution of the video increases, the size of the video will increase as well. There will be some cases when you can set an even bigger resolution than the camera hardware can support but this will only result in a very lagged and choppy video.
              </p>
              <p>
                Smoothing and Blurring techniques help us in eliminating noises from our image. There are various types of smoothing and blurring techniques available at direct disposal from open-cv. Let’s explore some of them to get adept with them. Keep in mind that each and every technique has its own advantages as well as disadvantages.
              </p>
              <p>
                <code>
                  #SMOOTHING AND BLURRING<br>
                  import numpy as np<br>
                  import cv2<br><br>
                  cap = cv2.VideoCapture(0)<br><br>
                  while True:<br>
                  &ensp;&ensp;&ensp;&ensp;_, frame = cap.read()<br><br>
                   
                  &ensp;&ensp;&ensp;&ensp;hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>
                  &ensp;&ensp;&ensp;&ensp;color_value_1 = np.arrays([0, 0, 0])<br>
                  &ensp;&ensp;&ensp;&ensp;color_value_2 = np.arrays([255, 255, 255])<br><br>
                  &ensp;&ensp;&ensp;&ensp;mask = cv2.inRange(hsv, color_value_1, color_value_2)<br><br>
                  &ensp;&ensp;&ensp;&ensp;result = cv2.bitwise_and(frame, frame, mask = mask)<br>
                  &ensp;&ensp;&ensp;&ensp;kernel = np.ones((10,10), np.float32)/100<br>
                  &ensp;&ensp;&ensp;&ensp;smooth_result = cv2.filter2D(result, -1, kernel)<br>
                  &ensp;&ensp;&ensp;&ensp;gaussian_blur = cv2.GaussianBlur(result, (10,10), 0)<br>
                  &ensp;&ensp;&ensp;&ensp;median_blur = cv2.medianBlur(result, 10)<br>
                  &ensp;&ensp;&ensp;&ensp;bilateral_blur = cv2.bilateralFilter(result, 10, 75, 75)<br><br>

                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('frame', frame)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('mask', mask)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('result', result)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('smooth_result', smooth_result)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('median_blur', median_blur)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('gaussian_blur', gaussian_blur)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('bilateral_blur', bilateral_blur)<br><br>
                  &ensp;&ensp;&ensp;&ensp;if waitKey(20) and 0xFF == ord('q'):<br>
                  &ensp;&ensp;&ensp;&ensp;break<br><br>
                  cv2.destroyAllWindows()<br>
                  cap.release()<br>
                </code>
              </p>
              <p>
                <ol>
                  <li>
                    As always we start by capturing the video frames from primary camera, reading in the frames, converting it from BGR (Blue, Green, Red) colour format to HSV (Hue, Saturation, Value) colour format.
                  </li>
                  <li>
                    We then define a range of numpy arrays as parameters to create a new mask frame.    
                  </li>
                  <li>
                    Performing a ‘BITWISE AND’ operation between original frame and masked frame.
                  </li>
                  <li>
                      Next we create a Kernel window, a block of an average 10 * 10 pixel (i.e 100 pixels) and apply all over averaging.
                  </li>
                  <li>
                      Lastly we look at different results by applying different blurring techniques such as Gaussian blur, median blur etc. Hence we can choose which style best suits our specific needs.
                  </li>
                </ol>
              </p>
              <p>
                After having a clear idea on the concept of Smoothing and Blurring we move towards our next topic. Canny edge detection does exactly as it sounds. It basically detects the edges from any given image. We are going to detect the edges from the live video input from the primary webcam.
              </p>
              <p>
                <code>
                  #CANNY EDGE DETECTION<br>
                  import cv2<br><br>
                  cap = cv2.VideoCapture(0)<br><br>
                  while True:<br>
                  &ensp;&ensp;&ensp;&ensp;_, frame = cap.read()<br>
                  &ensp;&ensp;&ensp;&ensp;hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>
                      
                  &ensp;&ensp;&ensp;&ensp;lower_threshold = int(max(0, (1.0 - 0.33) * median))<br>
                  &ensp;&ensp;&ensp;&ensp;upper_threshold = int(min(255, (1.0 + 0.33) * median))<br><br>
                      
                  &ensp;&ensp;&ensp;&ensp;edges = cv2.Canny(frame,lower_threshold,upper_threshold)<br>
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('Original',frame)<br><br>
                      
                  &ensp;&ensp;&ensp;&ensp;cv2.imshow('Edges',edges)<br><br>
                      
                  &ensp;&ensp;&ensp;&ensp;if cv2.waitKey(20) and 0xFF == ord('q'):<br>
                  &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;break<br><br>
                  cap.release()<br>
                  cv2.destroyAllWindows()
                </code>
              </p>
              <p>
                As all the above codes, this code is also quite straight forward.
              </p>
              <p>
                <ol>
                  <li>
                    We first capture the video input from the primary camera.
                  </li>
                  <li>
                    Converting the captured BGR (Blue, Green, Red) video into an HSV (Hue, Saturation, Value) colour format.
                  </li>
                  <li>
                    Defining the upper and lower threshold for the edge detection and passing those into the cv2.Canny() function will be the next step.
                  </li>
                  <li>
                    We then show the original image as well as the processed image.
                  </li>
                </ol>
              </p>
              <p>
                We will conclude this part here. This introductory part of the OPEN-CV series will be enough to get the basic understanding of how the Open-CV library, combined with python, works and it will also provide the grounds of understanding the field of Computer Vision itself. I have a <a href="https://github.com/Ishan3333/Open_CV_basics">Github repository</a> which contains all of the above code in a very well commented structure. The repository also contains all of the resources that I have used.
              </p>
              <p>
                Stay tuned. Until next time…!
              </p>
            </div> <!-- .col-md-8 -->

          </div>
        </div>
      </section>
      
      <footer class="ftco-footer ftco-bg-dark ftco-section">
        <div class="container">
          <div class="row mb-5 justify-content-center">
            <div class="col-md-5 text-center">
              <div class="ftco-footer-widget mb-5">
                <ul class="ftco-footer-social list-unstyled">
                  <li class="ftco-animate"><a href="https://www.linkedin.com/in/ishan-dixit-89012275/" target="_blank"><span class="icon-linkedin"></span></a></li>
                  <li class="ftco-animate"><a href="https://medium.com/@ishan.cdixit", target="_blank"><span class="icon-medium"></span></a></li>
                  <li class="ftco-animate"><a href="https://github.com/DixitIshan", target="_blank"><span class="icon-github"></span></a></li>
                </ul>
              </div>
              <div class="ftco-footer-widget">
                <h2 class="mb-3">Contact</h2>
                <p class="h3 email"><a href="#">ishan.cdixit@gmail.com</a></p>
              </div>
            </div>
          </div>
        </div>
      </footer>

      <!-- loader -->
      <div id="ftco-loader" class="show fullscreen"><svg class="circular" width="48px" height="48px"><circle class="path-bg" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke="#eeeeee"/><circle class="path" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke-miterlimit="10" stroke="#F96D00"/></svg></div>

      </div>

    </div>


    <script src="js/jquery.min.js"></script>
    <script src="js/jquery-migrate-3.0.1.min.js"></script>
    <script src="js/popper.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.easing.1.3.js"></script>
    <script src="js/jquery.waypoints.min.js"></script>
    <script src="js/jquery.stellar.min.js"></script>
    <script src="js/owl.carousel.min.js"></script>
    <script src="js/jquery.magnific-popup.min.js"></script>
    <script src="js/aos.js"></script>
    <script src="js/jquery.animateNumber.min.js"></script>
    <script src="js/scrollax.min.js"></script>
    <script src="js/bootstrap-datepicker.js"></script>
    <script src="js/jquery.timepicker.min.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBVWaKrjvy3MaE7SQ74_uJiULgl1JY0H2s&sensor=false"></script>
    <script src="js/google-map.js"></script>
    <script src="js/main.js"></script>
    
  </body>
</html>